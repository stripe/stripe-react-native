#!/bin/bash

set -uo pipefail

PLATFORM=""
RECORD_ON_FAILURE=false
RECORDING_PID=""

stop_recording() {
  local recording_dir=$1

  if [ -n "${RECORDING_PID:-}" ]; then
    echo "Stopping recording..."

    if [ "$PLATFORM" = "android" ]; then
      adb shell "kill -2 \$(cat /data/local/tmp/recording_pid.txt)" 2>/dev/null || true
      sleep 2
      adb pull /data/local/tmp/recording.mp4 "$recording_dir/recording.mp4" 2>/dev/null || true
      adb shell "rm -f /data/local/tmp/recording.mp4 /data/local/tmp/recording_pid.txt" 2>/dev/null || true

    elif [ "$PLATFORM" = "ios" ]; then
    local pid="$RECORDING_PID"

      if kill -0 "$pid" 2>/dev/null; then
        echo "Sending SIGINT to recordVideo (pid=$pid)..."
        # 1) Ask nicely with SIGINT to the whole process group
        kill -INT "-$pid" 2>/dev/null || true

        # 2) Wait up to ~5 seconds for it to exit on its own
        for i in {1..10}; do
          if ! kill -0 "$pid" 2>/dev/null; then
            break
          fi
          sleep 0.5
        done

        # 3) If still alive, escalate to SIGTERM
        if kill -0 "$pid" 2>/dev/null; then
          echo "recordVideo still running, sending SIGTERM..." >&2
          kill -TERM "-$pid" 2>/dev/null || true
          sleep 1
        fi

        # 4) If STILL alive, SIGKILL as last resort
        if kill -0 "$pid" 2>/dev/null; then
          echo "recordVideo still running, sending SIGKILL..." >&2
          kill -KILL "-$pid" 2>/dev/null || true
          # no need to sleep long here; wait will reap it
        fi
      fi

      # 5) Always wait here to reap the process (also handles zombies).
      #    This should NOT hang: after SIGKILL the child must be reaped.
      echo "Waiting for recordVideo (pid=$pid) to exit..."
      wait "$pid" 2>/dev/null || true
    fi

    RECORDING_PID=""
    echo "Recording saved to $recording_dir/recording.mp4"
  fi
}

start_recording() {
  local recording_dir=$1

  echo "Starting screen recording..."
  mkdir -p "$recording_dir"

  if [ "$PLATFORM" = "android" ]; then
    adb shell "screenrecord --bugreport /data/local/tmp/recording.mp4 & echo \$! > /data/local/tmp/recording_pid.txt" &
    RECORDING_PID="android"
  elif [ "$PLATFORM" = "ios" ]; then
    xcrun simctl io booted recordVideo --codec=h264 "$recording_dir/recording.mp4" &
    RECORDING_PID=$!
  fi
}

cleanup() {
  if [ -n "${RECORDING_PID:-}" ]; then
    echo "Interrupt cleanup - stopping recording..."
    if [ "$PLATFORM" = "android" ]; then
      adb shell "kill -2 \$(cat /data/local/tmp/recording_pid.txt)" 2>/dev/null || true
    elif [ "$PLATFORM" = "ios" ]; then
      kill -INT "-$RECORDING_PID" 2>/dev/null || true
    fi
    RECORDING_PID=""
  fi
}

handle_interrupt() {
  cleanup
  exit 130
}

trap cleanup EXIT
trap handle_interrupt INT TERM

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --record-on-failure)
      RECORD_ON_FAILURE=true
      ;;
    *)
      if [ -z "$PLATFORM" ]; then
        PLATFORM="$1"
      fi
      ;;
  esac
  shift
done

# Validate passed platform
case $PLATFORM in
  ios | android )
    ;;

  *)
    echo "Error! You must pass either 'android' or 'ios'"
    echo ""
    exit 1
    ;;
esac

if [ "$PLATFORM" == "ios" ]; then
  APPID="com.stripe.react.native"
  allTestFiles=$(ls ./e2e-tests/*.yml ./e2e-tests/ios-only/*.yml)
else
  APPID="com.stripe.react.native"
  allTestFiles=$(ls ./e2e-tests/*.yml ./e2e-tests/android-only/*.yml)
fi

failedTests=()
failedFinancialConnectionsTests=()

# Set defaults for optional environment variables
NEW_ARCH_ENABLED=${NEW_ARCH_ENABLED:-false}

# Ensure artifacts directory exists even if shard has no tests
mkdir -p e2e-artifacts

# Optional sharding configuration via environment variables
# Set SHARD_COUNT to the total number of shards and SHARD_INDEX to the index for this job (0-based)
SHARD_COUNT=${SHARD_COUNT:-}
SHARD_INDEX=${SHARD_INDEX:-}
if { [ -n "$SHARD_COUNT" ] || [ -n "$SHARD_INDEX" ]; } && { [ -z "$SHARD_COUNT" ] || [ -z "$SHARD_INDEX" ]; }; then
  echo "Error! Both SHARD_COUNT and SHARD_INDEX must be set to enable sharding."
  exit 1
fi

if [ -n "$SHARD_COUNT" ]; then
  if ! [[ $SHARD_COUNT =~ ^[0-9]+$ ]] || ! [[ $SHARD_INDEX =~ ^[0-9]+$ ]]; then
    echo "Error! SHARD_COUNT and SHARD_INDEX must be integers."
    exit 1
  fi
  if [ "$SHARD_COUNT" -le 0 ] || [ "$SHARD_INDEX" -lt 0 ] || [ "$SHARD_INDEX" -ge "$SHARD_COUNT" ]; then
    echo "Error! SHARD_INDEX must satisfy 0 <= SHARD_INDEX < SHARD_COUNT. Got SHARD_INDEX=$SHARD_INDEX, SHARD_COUNT=$SHARD_COUNT"
    exit 1
  fi
  echo "Sharding enabled: SHARD_INDEX=$SHARD_INDEX SHARD_COUNT=$SHARD_COUNT"
fi

# Retry configuration
MAX_ATTEMPTS=3
RETRY_DELAYS=(30 120) # Delay before retry 1, retry 2, etc.

idx=0
for file in $allTestFiles
do
  testName=$(basename "${file%.*}")
  testCmd="maestro test \"$file\" -e APP_ID=\"$APPID\" -e NEW_ARCH=\"$NEW_ARCH_ENABLED\" --flatten-debug-output"

  # Shard filter: only run files where (idx % SHARD_COUNT) == SHARD_INDEX
  if [ -n "$SHARD_COUNT" ]; then
    mod=$(( idx % SHARD_COUNT ))
    if [ "$mod" -ne "$SHARD_INDEX" ]; then
      idx=$((idx + 1))
      continue
    fi
  fi

  success=false
  for attempt in $(seq 1 $MAX_ATTEMPTS); do
    # Determine artifact directory name
    if [ "$attempt" -eq 1 ]; then
      artifactDir="e2e-artifacts/$testName"
    else
      artifactDir="e2e-artifacts/$testName-retry-$((attempt - 1))"
    fi

    # Start recording on retry attempts (after first failure)
    if [ "$attempt" -gt 1 ] && [ "$RECORD_ON_FAILURE" = "true" ]; then
      start_recording "$artifactDir"
    fi

    if eval "$testCmd --debug-output $artifactDir"; then
      # Stop recording if it was running
      if [ "$attempt" -gt 1 ] && [ "$RECORD_ON_FAILURE" = "true" ]; then
        stop_recording "$artifactDir"
      fi
      success=true
      break
    fi

    # Stop recording if it was running
    if [ "$attempt" -gt 1 ] && [ "$RECORD_ON_FAILURE" = "true" ]; then
      stop_recording "$artifactDir"
    fi

    # If not the last attempt, wait before retrying
    if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
      delay=${RETRY_DELAYS[$((attempt - 1))]}
      echo "Test ${file} failed. Retrying in ${delay}s..."
      sleep "$delay"
    fi
  done

  if [ "$success" = false ]; then
    failedTests+=("$file")
    if [[ "$testName" == *"financial-connections"* ]]; then
      failedFinancialConnectionsTests+=("$file")
    fi
  fi

  idx=$((idx + 1))
done

if [ ${#failedTests[@]} -eq 0 ]; then
    exit 0
else
    echo "These tests failed:"
    printf '%s\n' "${failedTests[@]}"
    exit 1
fi
